// NLOC - source line counter tool
// Copyright (C) 2007 Balazs Tihanyi
// 
// This program is free software; you can redistribute it and/or modify it under 
// the terms of the GNU General Public License as published by the Free Software 
// Foundation; either version 3 of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, but WITHOUT 
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with 
// this program; if not, write to the Free Software Foundation, Inc., 
// 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

using System;
using System.IO;
using NLOC.Core;

namespace NLOC.Console
{
	/// <summary>
	/// Provides interpretation of command-line arguments.
	/// </summary>
	internal class ArgumentInterpreter : ITaskParameters
	{
		FileSet fileSet = new FileSet();
		string output = null;
		string outputXml = null;
		ReportElements visibleElements =
			ReportElements.Files | ReportElements.Projects | ReportElements.Summary;
		bool showPercentage = false;
		bool showLogo = true;
		bool showHelp = false;

		/// <summary>
		/// Initializes a new instance of the <see cref="ArgumentInterpreter"/> class 
		/// with the specified command-line arguments.
		/// </summary>
		/// <param name="args">An array of command-line arguments.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="args"/> is null.
		/// </exception>
		/// <exception cref="InvalidArgumentException">
		/// Command line argument(s) are invalid.
		/// </exception>
		public ArgumentInterpreter(string[] args)
		{
			if (args == null)
				throw new ArgumentNullException("args");

			ParseArgs(args);
		}

		/// <summary>
		/// An <see cref="IFileHandler"/> object which is generated by the include 
		/// file specifications.
		/// </summary>
		public IFileHandler FileSet
		{
			get { return fileSet; }
		}

		/// <summary>
		/// Gets the output path of the text file report.
		/// </summary>
		/// <remarks>It can be specified with the <c>-out</c> parameter.</remarks>
		/// <value>The output path string or null if the output is not defined.</value>
		public string Output
		{
			get { return output; }
		}

		/// <summary>
		/// Gets the output path of the XML report.
		/// </summary>
		/// <remarks>It can be specified with the <c>-out_xml</c> parameter.</remarks>
		/// <value>The output path string or null if the output is not defined.</value>
		public string OutputXml
		{
			get { return outputXml; }
		}

		/// <summary>
		/// Gets a <see cref="ReportElements"/> object that represents 
		/// what to show in the report.
		/// </summary>
		/// <remarks>It can be specified with the <c>-show</c> parameter.</remarks>
		public ReportElements VisibleElements
		{
			get { return visibleElements; }
		}

		/// <summary>
		/// Gets a value indicating whether to show percentage instead of number of lines.
		/// </summary>
		/// <remarks>It can be specified with the <c>-percentage</c> parameter.</remarks>
		public bool ShowPercentage
		{
			get { return showPercentage; }
		}

		/// <summary>
		/// Gets a value indicating whether to show logo informations.
		/// </summary>
		/// <remarks>It can be suppressed with the <c>-nologo</c> parameter.</remarks>
		public bool ShowLogo
		{
			get { return showLogo; }
		}

		/// <summary>
		/// Gets a value indicating whether to show usage instructions.
		/// </summary>
		/// <remarks>It can be specified with the <c>-help</c> parameter.</remarks>
		public bool ShowHelp
		{
			get { return showHelp; }
		}

		/// <exception cref="InvalidArgumentException">
		/// Command line argument is invalid.
		/// </exception>
		private void ParseArgs(string[] args)
		{
			for (int i = 0; i < args.Length; i++) {
				string argument = args[i];

				if (argument.StartsWith("-"))
					ParseOption(argument);
				else
					ParseIncludePattern(argument);
			}

			// Remove files matching the exclude patterns
			fileSet.ValidateExcludePatterns();
		}

		/// <exception cref="InvalidArgumentException">
		/// Input file is invalid.
		/// </exception>
		private void ParseIncludePattern(string argument)
		{
			string path = argument;
			string projectName = null;

			if (path != null) {
				// Read project name
				int separatorIndex = path.IndexOf(';');
				if (separatorIndex >= 0 && path.Length > separatorIndex + 1) {
					projectName = path.Substring(separatorIndex + 1);
					path = path.Substring(0, separatorIndex);
				}
			}

			try {
				string extension = Path.GetExtension(path);

				if (extension == ".csproj" || extension == ".vbproj" ||
					extension == ".vcproj" || extension == ".vjsproj")
				{
					fileSet.AddProject(path);
				}
				else if (extension == ".sln") {
					fileSet.AddSolution(path);
				}
				else {
					fileSet.AddFile(path, projectName);
				}
			}
			catch (ArgumentException ex) {
				throw new InvalidArgumentException(argument,
					"Input file '" + argument + "' is invalid or could not be found.\n" +
					"Reason: " + ex.Message, ex);
			}
		}

		/// <exception cref="InvalidArgumentException">
		/// Command line argument is invalid.
		/// </exception>
		private void ParseOption(string argument)
		{
			if (argument.StartsWith("-out:")) {
				if (argument == "-out:") {
					throw new InvalidArgumentException(argument,
						"Missing <file> parameter for '-out' option.");
				}
				output = argument.Substring(5);
			}
			else if (argument.StartsWith("-out_xml:")) {
				if (argument == "-out_xml:") {
					throw new InvalidArgumentException(argument,
						"Missing <file> parameter for '-out_xml' option.");
				}
				outputXml = argument.Substring(9);
			}
			else if (argument.StartsWith("-recurse:")) {
				if (argument == "-recurse:") {
					throw new InvalidArgumentException(argument,
						"Missing <path> parameter for '-recurse' option.");
				}
				ParseRecursePath(argument.Substring(9));
			}
			else if (argument.StartsWith("-r:")) {
				if (argument == "-r:") {
					throw new InvalidArgumentException(argument,
						"Missing <path> parameter for '-recurse' option.");
				}
				ParseRecursePath(argument.Substring(3));
			}
			else if (argument.StartsWith("-exclude:")) {
				if (argument == "-exclude:") {
					throw new InvalidArgumentException(argument,
						"Missing parameter for '-exclude' option.");
				}
				ParseExcludeOption(argument.Substring(9));
			}
			else if (argument.StartsWith("-e:")) {
				if (argument == "-e:") {
					throw new InvalidArgumentException(argument,
						"Missing parameter for '-exclude' option.");
				}
				ParseExcludeOption(argument.Substring(3));
			}
			else if (argument.StartsWith("-show:")) {
				if (argument == "-show:") {
					throw new InvalidArgumentException(argument,
						"Missing parameter for '-show' option.");
				}
				ParseShowOption(argument.Substring(6));
			}
			else if (argument == "-p" || argument == "-percentage") {
				showPercentage = true;
			}
			else if (argument == "-nologo") {
				showLogo = false;
			}
			else if (argument == "-help" || argument == "/help" ||
				argument == "-?" || argument == "/?") {
				showHelp = true;
			}
			else {
				throw new InvalidArgumentException(argument);
			}
		}

		/// <exception cref="InvalidArgumentException">
		/// <paramref name="path"/> is invalid.
		/// </exception>
		private void ParseRecursePath(string path)
		{
			string projectName = null;

			// Read project name
			int separatorIndex = path.IndexOf(';');
			if (separatorIndex >= 0 && path.Length > separatorIndex + 1) {
				projectName = path.Substring(separatorIndex + 1);
				path = path.Substring(0, separatorIndex);
			}

			try {
				fileSet.AddFilesRecursively(path, projectName);
			}
			catch (ArgumentException ex) {
				throw new InvalidArgumentException(path, "Recurse path '" +
					path + "' is invalid or its subfolder(s) cannot be listed.", ex);
			}
		}

		/// <exception cref="InvalidArgumentException">
		/// <paramref name="param"/> is invalid.
		/// </exception>
		private void ParseExcludeOption(string param)
		{
			fileSet.AddExludePattern(param);
		}

		/// <exception cref="InvalidArgumentException">
		/// <paramref name="param"/> is invalid.
		/// </exception>
		private void ParseShowOption(string param)
		{
			ReportElements elements = (ReportElements) 0;

			for (int i = 0; i < param.Length; i++) {
				char paramChar = param[i];

				if (paramChar == 'f') {      // Show files
					elements |= ReportElements.Files;
				}
				else if (paramChar == 'p') { // Show projects
					elements |= ReportElements.Projects;
				}
				else if (paramChar == 's') { // Show summary
					elements |= ReportElements.Summary;
				}
				else {
					throw new InvalidArgumentException(param,
						"Invalid '" + paramChar + "' parameter for '-show' option.");
				}
			}

			visibleElements = elements;
		}
	}
}
